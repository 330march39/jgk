<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>情報処理入門</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- Tone.js library for sound effects -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        /* CSS Variables for Theming */
        :root {
            /* Light Mode Default Colors */
            --bg-primary: #f0f9ff;
            --bg-secondary: #ffffff;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --button-bg-default: #f1f5f9;
            --button-text-default: #334155;
            --button-border-default: #cbd5e1;
            --nav-button-bg: #0ea5e9;
            --nav-button-hover-bg: #0284c7;
            --nav-button-shadow: rgba(14, 165, 233, 0.3);
            --start-button-bg: #10b981;
            --start-button-hover-bg: #059669;
            --start-button-shadow: rgba(16, 185, 129, 0.3);
            --interrupt-button-bg: #ef4444;
            --interrupt-button-hover-bg: #dc2626;
            --interrupt-button-shadow: rgba(239, 68, 68, 0.3);
            --progress-bar-bg: #0ea5e9;
            --feedback-bg: #f8fafc;
            --feedback-border: #e2e8f0;
            --correct-feedback-text: #15803d;
            --correct-feedback-border: #22c55e;
            --incorrect-feedback-text: #b91c1c;
            --incorrect-feedback-border: #ef4444;
            --correct-option-bg: #dcfce7;
            --incorrect-option-bg: #fee2e2;
            --score-color: #0c4a6e;
            --score-comment-color: #0369a1;
            --settings-button-bg: #6366f1;
            --settings-button-hover-bg: #4f46e5;
            --settings-button-shadow: rgba(99, 102, 241, 0.3);
            --themed-text-color: #0c4a6e; /* Default themed text color */
            
            /* Themed Background Colors */
            --bg-primary-default: #f0f9ff;
            --bg-primary-red: #fff1f2;
            --bg-primary-green: #f0fdf4;
            --bg-primary-indigo: #f5f3ff;
        }

        /* Dark Mode Colors */
        body.dark-mode {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --text-primary: #e2e8f0;
            --text-secondary: #94a3b8;
            --button-bg-default: #334155;
            --button-text-default: #e2e8f0;
            --button-border-default: #475569;
            --nav-button-bg: #38bdf8;
            --nav-button-hover-bg: #0ea5e9;
            --nav-button-shadow: rgba(56, 189, 248, 0.3);
            --start-button-bg: #2dd4bf;
            --start-button-hover-bg: #14b8a6;
            --start-button-shadow: rgba(45, 212, 191, 0.3);
            --interrupt-button-bg: #f87171;
            --interrupt-button-hover-bg: #ef4444;
            --interrupt-button-shadow: rgba(248, 113, 113, 0.3);
            --progress-bar-bg: #38bdf8;
            --feedback-bg: #334155;
            --feedback-border: #475569;
            --correct-feedback-text: #a7f3d0;
            --correct-feedback-border: #4ade80;
            --incorrect-feedback-text: #fecaca;
            --incorrect-feedback-border: #f87171;
            --correct-option-bg: #14532d;
            --incorrect-option-bg: #7f1d1d;
            --score-color: #e0f2fe;
            --score-comment-color: #7dd3fc;
            --settings-button-bg: #818cf8;
            --settings-button-hover-bg: #6366f1;
            --settings-button-shadow: rgba(129, 140, 248, 0.3);
            --themed-text-color: #e0f2fe; /* Default themed text color for dark mode */

            /* Themed Background Colors (Dark) */
            --bg-primary-default: #0f172a;
            --bg-primary-red: #261012;
            --bg-primary-green: #0d1f12;
            --bg-primary-indigo: #1a1b2d;
        }

        body {
            font-family: 'Noto Sans JP', 'Inter', sans-serif;
            background-color: var(--bg-primary);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
            transition: background-color 0.3s ease;
        }
        .container {
            background-color: var(--bg-secondary);
            border-radius: 20px;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.15);
            padding: 25px;
            width: 100%;
            max-width: 700px;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 15px;
            position: relative;
            z-index: 1;
            transition: background-color 0.3s ease;
        }
        .screen {
            display: none;
            flex-direction: column;
            gap: 15px;
        }
        .screen.active {
            display: flex;
        }
        .main-title {
            color: var(--themed-text-color);
            transition: color 0.3s ease;
        }
        .question-area {
            min-height: 150px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: var(--feedback-bg);
            border-radius: 10px;
            padding: 20px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
            transition: background-color 0.3s ease;
            text-align: left;
        }
        .question-text-wrapper {
            display: flex;
            flex-direction: column;
            width: 100%;
        }
        .question-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        .question-text {
            font-size: 1.25rem;
            font-weight: 500;
            color: var(--themed-text-color);
            transition: color 0.3s ease;
            flex-grow: 1;
        }
        .question-text img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            margin-top: 15px;
            border: 1px solid var(--button-border-default);
        }
        .similarity-tag {
            padding: 3px 8px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 700;
            color: white;
            flex-shrink: 0;
        }
        .similarity-tag.same { background-color: #3b82f6; } /* blue */
        .similarity-tag.numbers { background-color: #16a34a; } /* green */
        .similarity-tag.trend { background-color: #f97316; } /* orange */
        
        .question-text table {
            width: auto;
            margin: 15px auto;
            border-collapse: collapse;
            background-color: var(--bg-secondary);
            color: var(--text-primary);
        }
        .question-text th, .question-text td {
            border: 1px solid var(--button-border-default);
            padding: 8px;
            text-align: center;
        }
        .question-text th {
            background-color: var(--button-bg-default);
        }
        .options-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
            margin-top: 15px;
        }
        .option-button, .option-checkbox-wrapper {
            background-color: var(--button-bg-default);
            color: var(--button-text-default);
            padding: 14px 20px;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid var(--button-border-default);
            text-align: left;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.08);
            line-height: 1.5;
        }
        .option-button:hover, .option-checkbox-wrapper:hover {
            background-color: var(--button-border-default);
            transform: translateY(-3px) scale(1.01);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.12);
        }
        .option-checkbox-wrapper {
            display: flex;
            align-items: center;
        }
        .option-checkbox-wrapper input[type="checkbox"] {
            width: 1.2em;
            height: 1.2em;
            margin-right: 12px;
            accent-color: var(--nav-button-bg);
        }
        .option-button.correct, .option-checkbox-wrapper.correct {
            background-color: var(--correct-option-bg);
            border-color: var(--correct-feedback-border);
            color: var(--correct-feedback-text);
            box-shadow: 0 4px 8px rgba(34, 197, 94, 0.2);
        }
        .option-button.incorrect, .option-checkbox-wrapper.incorrect {
            background-color: var(--incorrect-option-bg);
            border-color: var(--incorrect-feedback-border);
            color: var(--incorrect-feedback-text);
            box-shadow: 0 4px 8px rgba(239, 68, 68, 0.2);
        }
        .navigation-buttons {
            display: flex;
            justify-content: flex-end;
            margin-top: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }
        .nav-button {
            background-color: var(--nav-button-bg);
            color: white;
            padding: 12px 25px;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 5px 15px var(--nav-button-shadow);
            border: none;
        }
        .nav-button:hover {
            background-color: var(--nav-button-hover-bg);
            transform: translateY(-2px);
            box-shadow: 0 7px 20px var(--nav-button-shadow);
        }
        .nav-button:disabled {
            background-color: #94a3b8;
            cursor: not-allowed;
            box-shadow: none;
        }
        .feedback-message {
            margin-top: 10px;
            font-size: 1rem;
            font-weight: 600;
            text-align: left;
            padding: 10px 15px;
            border-radius: 12px;
            background-color: var(--feedback-bg);
            border: 1px solid var(--feedback-border);
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
            line-height: 1.5;
            transition: all 0.3s ease;
        }
        .feedback-message.correct-feedback {
            color: var(--correct-feedback-text);
            border-color: var(--correct-feedback-border);
        }
        .feedback-message.incorrect-feedback {
            color: var(--incorrect-feedback-text);
            border-color: var(--incorrect-feedback-border);
        }
        .feedback-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 15px;
            min-height: 24px;
        }
        .feedback-result {
            flex-grow: 1;
        }
        .feedback-result strong {
            font-size: 1.1rem;
        }
        .explanation-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-out, padding-top 0.4s ease-out, margin-top 0.4s ease-out;
            padding-top: 0;
            margin-top: 0;
        }
        .explanation-content.show {
            max-height: 200px;
            padding-top: 10px;
            margin-top: 10px;
            border-top: 1px solid var(--feedback-border);
        }
        .explanation-text {
            font-weight: 400;
            font-size: 0.95rem;
            transition: color 0.3s ease;
        }
        .feedback-message.correct-feedback .explanation-text {
            color: var(--correct-feedback-text);
        }
        .feedback-message.incorrect-feedback .explanation-text {
            color: var(--incorrect-feedback-text);
        }
        .toggle-explanation-button {
            background-color: var(--nav-button-bg);
            color: white;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 2px 5px var(--nav-button-shadow);
            flex-shrink: 0;
        }
        .toggle-explanation-button:hover {
            transform: translateY(-1px);
        }
        .toggle-explanation-button.hidden {
            display: none;
        }
        .score-area {
            font-size: 1.8rem;
            font-weight: 800;
            color: var(--score-color);
            margin-top: 25px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
            transition: color 0.3s ease;
        }
        .score-comment {
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--score-comment-color);
            margin-top: 10px;
            transition: color 0.3s ease;
        }
        .mode-selection-dropdown, .question-count-selection {
            margin-bottom: 15px;
        }
        .mode-selection-dropdown label, .question-count-selection label {
            display: block;
            text-align: left;
            margin-bottom: 5px;
            font-weight: 600;
            color: var(--text-primary);
        }
        .mode-selection-dropdown select, .question-count-selection select {
            width: 100%;
            padding: 12px;
            border-radius: 10px;
            border: 1px solid var(--button-border-default);
            font-size: 1rem;
            background-color: var(--button-bg-default);
            color: var(--button-text-default);
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%2020%2020%22%20fill%3D%22%23333%22%3E%3Cpath%20fill-rule%3D%22evenodd%22%20d%3D%22M5.293%207.293a1%201%200%20011.414%200L10%2010.586l3.293-3.293a1%201%200%20111.414%201.414l-4%204a1%201%200%2001-1.414%200l-4-4a1%201%200%20010-1.414z%22%20clip-rule%3D%22evenodd%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 1.2em;
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }
        .start-button {
            background-color: var(--start-button-bg);
            color: white;
            padding: 15px 30px;
            border-radius: 12px;
            font-size: 1.2rem;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 6px 15px var(--start-button-shadow);
            margin-top: 20px;
            border: none;
        }
        .start-button:hover {
            background-color: var(--start-button-hover-bg);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px var(--start-button-shadow);
        }
        #settingsButton {
            background-color: var(--settings-button-bg);
            box-shadow: 0 5px 15px var(--settings-button-shadow);
        }
        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); display: flex; justify-content: center; align-items: center; z-index: 1000; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal.show { opacity: 1; visibility: visible; }
        .modal-content { background-color: var(--bg-secondary); padding: 35px; border-radius: 20px; text-align: center; box-shadow: 0 15px 40px rgba(0, 0, 0, 0.3); max-width: 450px; width: 90%; transform: translateY(-30px); transition: transform 0.3s ease, background-color 0.3s ease; }
        .modal.show .modal-content { transform: translateY(0); }
        .modal-title { font-size: 2rem; font-weight: 800; color: var(--score-color); margin-bottom: 20px; transition: color 0.3s ease; }
        .modal-message { font-size: 1.2rem; color: var(--text-primary); margin-bottom: 30px; line-height: 1.6; transition: color 0.3s ease; }
        .modal-buttons { display: flex; justify-content: center; gap: 15px; }
        .modal-button { background-color: var(--nav-button-bg); color: white; padding: 12px 30px; border-radius: 10px; font-size: 1.1rem; font-weight: 600; cursor: pointer; transition: background-color 0.3s ease, transform 0.2s ease; box-shadow: 0 4px 10px var(--nav-button-shadow); border: none; }
        .modal-button:hover { background-color: var(--nav-button-hover-bg); transform: translateY(-1px); }
        #modalCancelButton { background-color: #64748b; box-shadow: 0 4px 10px rgba(100, 116, 139, 0.3); }
        #modalCancelButton:hover { background-color: #475569; }
        .progress-container { width: 100%; background-color: #e2e8f0; border-radius: 10px; height: 15px; margin-top: 10px; overflow: hidden; box-shadow: inset 0 1px 3px rgba(0,0,0,0.1); }
        .progress-bar { height: 100%; width: 0%; background-color: var(--progress-bar-bg); border-radius: 10px; transition: width 0.3s ease-in-out, background-color 0.3s ease; }
        .progress-text { font-size: 1rem; font-weight: 600; color: var(--text-primary); margin-top: 10px; transition: color 0.3s ease; }
        .quiz-header {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding-top: 1.5rem;
            padding-bottom: 0.5rem;
            gap: 1rem;
        }
        .quiz-header .main-title {
            flex-grow: 1;
            text-align: center;
            font-size: 1.5rem;
            margin: 0;
            padding: 0 4rem; /* Add padding to avoid overlap */
        }
        #interruptButton {
            position: absolute;
            top: 50%;
            right: 0;
            transform: translateY(-50%);
            padding: 8px 15px;
            font-size: 0.8rem;
        }
        
        .confetti-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; pointer-events: none; z-index: 0; }
        .confetti { position: absolute; width: 10px; height: 10px; background-color: #f06; opacity: 1; }
        
        .settings-option { display: flex; justify-content: space-between; align-items: center; padding: 12px 0; border-bottom: 1px solid var(--button-border-default); flex-wrap: nowrap; gap: 1rem;}
        .settings-option:last-child { border-bottom: none; }
        .settings-option-label { display: flex; flex-direction: column; align-items: flex-start; flex-grow: 1; min-width: 0; }
        .settings-option-label label { font-size: 1.1rem; color: var(--text-primary); font-weight: 600; }
        .settings-option-label p { font-size: 0.85rem; color: var(--text-secondary); margin: 4px 0 0 0; text-align: left; }
        .theme-colors { display: flex; gap: 10px; }
        .color-circle { width: 30px; height: 30px; border-radius: 50%; cursor: pointer; border: 2px solid transparent; transition: border-color 0.2s ease; }
        .color-circle.selected { border-color: var(--nav-button-bg); }
        .toggle-switch { position: relative; display: inline-block; width: 60px; height: 34px; flex-shrink: 0; margin-left: auto; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--nav-button-bg); }
        input:checked + .slider:before { transform: translateX(26px); }

        @media (min-width: 640px) {
            .options-grid {
                grid-template-columns: 1fr 1fr;
            }
            .quiz-header .main-title {
                font-size: 1.875rem; /* text-3xl */
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="confettiContainer" class="confetti-container"></div>

        <!-- スタート画面 -->
        <div id="startScreen" class="screen active">
            <h1 class="text-3xl font-bold mb-6 main-title">情報処理入門</h1>
            <p class="text-lg mb-4" style="color: var(--text-primary);">学習したいモードを選択してください。</p>
            <div class="mode-selection-dropdown">
                <select id="quizModeSelect">
                    <optgroup label="2024年度 過去問題">
                        <option value="2024-all">2024年度 全ての大問</option>
                        <option value="2024-daimon1">大問 1~2</option>
                        <option value="2024-daimon2">大問 3~4</option>
                        <option value="2024-daimon3">大問 5~7</option>
                        <option value="2024-daimon4">大問 8~9</option>
                        <option value="2024-daimon5">大問 10~12</option>
                        <option value="2024-daimon6">大問 13~14</option>
                        <option value="2024-daimon7">大問 15~16</option>
                        <option value="2024-daimon8">大問 17~18</option>
                        <option value="2024-daimon9">大問 19~20</option>
                    </optgroup>
                    <optgroup label="2023年度 過去問題">
                        <option value="2023-all">2023年度 全ての大問</option>
                        <option value="2023-daimon1">大問 1~2</option>
                        <option value="2023-daimon2">大問 3~4</option>
                        <option value="2023-daimon3">大問 5~7</option>
                        <option value="2023-daimon4">大問 8~9</option>
                        <option value="2023-daimon5">大問 10~12</option>
                        <option value="2023-daimon6">大問 13~14</option>
                        <option value="2023-daimon7">大問 15~16</option>
                        <option value="2023-daimon8">大問 17~18</option>
                        <option value="2023-daimon9">大問 19~20</option>
                    </optgroup>
                    <optgroup label="その他">
                        <option value="incorrect">苦手克服モード</option>
                    </optgroup>
                </select>
            </div>
            <button id="startButton" class="start-button">クイズ開始</button>
            <button id="settingsButton" class="nav-button">設定</button>
        </div>

        <!-- クイズ画面 -->
        <div id="quizScreen" class="screen">
            <div class="quiz-header">
                <h1 class="main-title font-bold">情報処理入門</h1>
                <button id="interruptButton" class="nav-button">中断</button>
            </div>
            <div class="progress-container">
                <div id="progressBar" class="progress-bar"></div>
            </div>
            <div id="progressText" class="progress-text"></div>

            <div class="question-area">
                <div id="questionTextWrapper" class="question-text-wrapper">
                    <!-- Question header (text + similarity tag) will be injected here -->
                </div>
            </div>

            <div id="optionsGrid" class="options-grid"></div>

            <div id="feedbackMessage" class="feedback-message" style="display: none;">
                <div class="feedback-header">
                    <div id="feedbackResult"></div>
                    <button id="toggleExplanationButton" class="toggle-explanation-button hidden">解説▼</button>
                </div>
                <div id="explanationContent" class="explanation-content">
                    <div class="explanation-text"></div>
                </div>
            </div>

            <div class="navigation-buttons">
                <button id="nextButton" class="nav-button">次の問題</button>
            </div>
        </div>

        <!-- 結果画面 -->
        <div id="resultScreen" class="screen">
            <h1 class="text-3xl font-bold mb-6 main-title">情報処理入門</h1>
            <h2 class="text-2xl font-bold mb-4" style="color: var(--score-color);">クイズ結果</h2>
            <div id="finalScore" class="score-area"></div>
            <div id="scoreComment" class="score-comment"></div>
            <button id="restartButton" class="nav-button mt-6">もう一度プレイ</button>
            <button id="redoIncorrectButton" class="nav-button mt-2" style="background-color: var(--interrupt-button-bg);">間違えた問題をもう一度やる</button>
        </div>

        <!-- 設定画面 -->
        <div id="settingsScreen" class="screen">
            <h1 class="text-3xl font-bold mb-6 main-title">情報処理入門</h1>
            <h2 class="text-2xl font-bold mb-4 main-title">設定</h2>
            <div class="settings-option">
                <div class="settings-option-label">
                    <label for="darkModeToggle">ダークモード</label>
                </div>
                <label class="toggle-switch">
                    <input type="checkbox" id="darkModeToggle">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="settings-option">
                <div class="settings-option-label">
                    <label>テーマカラー</label>
                </div>
                <div class="theme-colors">
                    <div class="color-circle" data-theme="default" style="background-color: #0ea5e9;"></div>
                    <div class="color-circle" data-theme="red" style="background-color: #ef4444;"></div>
                    <div class="color-circle" data-theme="green" style="background-color: #10b981;"></div>
                    <div class="color-circle" data-theme="indigo" style="background-color: #6366f1;"></div>
                </div>
            </div>
            <div class="settings-option">
                <div class="settings-option-label">
                    <label for="questionCountSelect">問題数</label>
                    <p>各「大問」モードでは全問出題されます。</p>
                </div>
                <select id="questionCountSelect">
                    <option value="5">5問</option>
                    <option value="10">10問</option>
                    <option value="15">15問</option>
                    <option value="20">20問</option>
                </select>
            </div>
            <div class="settings-option">
                <div class="settings-option-label">
                    <label for="showProgressToggle">進捗状況を表示</label>
                </div>
                <label class="toggle-switch">
                    <input type="checkbox" id="showProgressToggle">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="settings-option">
                <div class="settings-option-label">
                    <label for="enableSoundToggle">効果音</label>
                </div>
                <label class="toggle-switch">
                    <input type="checkbox" id="enableSoundToggle">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="settings-option">
                <div class="settings-option-label">
                    <label for="masteryModeToggle">習得モード</label>
                    <p>すべての問題は2回連続で正解するまで「習得済み」になりません。</p>
                </div>
                <label class="toggle-switch">
                    <input type="checkbox" id="masteryModeToggle">
                    <span class="slider"></span>
                </label>
            </div>
            <button id="backToStartButton" class="nav-button mt-6">戻る</button>
        </div>
    </div>

    <!-- モーダル -->
    <div id="modal" class="modal">
        <div class="modal-content">
            <h2 id="modalTitle" class="modal-title"></h2>
            <p id="modalMessage" class="modal-message"></p>
            <div class="modal-buttons">
                <button id="modalConfirmButton" class="modal-button">はい</button>
                <button id="modalCancelButton" class="modal-button">キャンセル</button>
            </div>
        </div>
    </div>

    <script>
        // --- アプリ固有のID ---
        const APP_PREFIX = 'INFO_PROCESSING_QUIZ_V2_';

        // --- 画像データ ---
        const logicCircuitImage = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAoAAAAHgCAYAAAAfD/naAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGgAAP+lSURBVHhepP1p31zZdt/73nuv3z33vef73vO+53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne53ne5-glove-2023-TE-2/q16.png';
        
        // --- 問題データ (ここから) ---
        const allQuestions = [
            // --- 2024年度 ---
            { id: '24-q1', year: 2024, daimon: '問1', type: 'calculation', text: "符号なし16進法のDを2進法4桁に変換しなさい。", options: ["1011", "1100", "1101", "1110"], answer: "1101", explanation: "16進数のDは10進数で13です。13を2進数に変換すると8+4+0+1 = 1101となります。", similarity: { type: 'trend', ref: '23-q1' } },
            { id: '24-q2', year: 2024, daimon: '問2', type: 'calculation', text: "16進法で4bitの2の補数表示した2数、3+Bの結果を10進法で答えなさい。", options: ["-2", "-3", "14", "8"], answer: "-2", explanation: "16進数の3は2進数で0011。16進数のBは10進数で11、2進数で1011です。1011は最上位ビットが1なので負数です。2の補数を求める(元の負の数値を求める)には、全ビットを反転(0100)して1を加える(0101)と5になります。つまり1011は-5です。よって、3 + (-5) = -2となります。", similarity: { type: 'numbers', ref: '23-q2' } },
            { id: '24-q3', year: 2024, daimon: '問3', type: 'multiple', text: "デジタル化について次の文のうち正しいものを全て選びなさい。", options: ["a. デジタルデータの最小単位はバイトである。", "b. アナログデータをデジタルデータに変換することをA/D変換と言う。", "c. 多数のデジタルデータから一部データを抜き出すことを標本化と言う。", "d. 標本化周波数を引き上げると量子化bit数 高くなる。", "e. アナログ値データを離散的な値のいずれかにする処理を量子化と言う。", "f. 量子化した値に具体的なbit列を割り当てることを符号化と言う。"], answer: ["b. アナログデータをデジタルデータに変換することをA/D変換と言う。", "e. アナログ値データを離散的な値のいずれかにする処理を量子化と言う。", "f. 量子化した値に具体的なbit列を割り当てることを符号化と言う。"], explanation: "aは誤り(最小単位はビット)、cは誤り(アナログデータから抜き出すのが標本化)、dは誤り(標本化周波数と量子化ビット数は独立したパラメータ)。b, e, fが正しい説明です。", similarity: { type: 'trend', ref: '23-q3' } },
            { id: '24-q4', year: 2024, daimon: '問4', type: 'calculation', text: "量子化ビット数16bit、標本化周波数48kHzの音声データ1秒間でのデータ量を答えなさい。kやMを使って良い。本間に限りk=10^3, M=10^6として計算しなさい。", options: ["96kB", "768kB", "96kbit", "768Mbit"], answer: "96kB", explanation: "データ量(bit) = 16 bit * 48,000 Hz = 768,000 bit/s。バイトに変換するには8で割ります。768,000 / 8 = 96,000 Byte/s。k=10^3なので96kBとなります。", similarity: { type: 'numbers', ref: '23-q4' } },
            { id: '24-q5', year: 2024, daimon: '問5', type: 'same', text: "コンピュータの基本機能装置の関係を示した図で、A,B,C装置にそれぞれ当てはまる名称を漢字で答えなさい。", options: ["A:制御装置, B:演算装置, C:主記憶装置", "A:演算装置, B:制御装置, C:主記憶装置", "A:主記憶装置, B:演算装置, C:制御装置", "A:制御装置, B:主記憶装置, C:演算装置"], answer: "A:制御装置, B:演算装置, C:主記憶装置", explanation: "コンピュータの五大装置に基づくと、プロセッサは制御装置(A)と演算装置(B)から構成され、主記憶装置(C)とやり取りします。", similarity: { type: 'same', ref: '23-q5' } },
            { id: '24-q6', year: 2024, daimon: '問6', type: 'same', text: "図はプロセッサによってフェッチされた命令の格納順序を表している。「a」に当てはまるものを語群から選びなさい。(語群: アドレス演算器、算術論理演算器、フラグレジスタ、命令レジスタ、パイプライン、プログラムカウンタ、アドレスパス)", options: ["命令レジスタ", "プログラムカウンタ", "アドレス演算器", "デコーダ"], answer: "命令レジスタ", explanation: "主記憶から読み出された命令は、まず命令レジスタに格納され、その後デコーダによって解読されます。", similarity: { type: 'same', ref: '23-q6' } },
            { id: '24-q7', year: 2024, daimon: '問7', type: 'same', text: "5つの実行ステージが各1クロックサイクルで実行されるパイプライン動作のCPUがある。命令実行あたり1クロックサイクルの待ち(バブル)が発生する場合、その命令1命令だけの実行にかかる時間を答えなさい。ただし、クロック周波数は2GHzとする。", options: ["2.5ns", "3.0ns", "5ns", "6ns"], answer: "3.0ns", explanation: "1命令の実行には通常5ステージ(5クロック)かかります。バブルが1クロック発生するので合計6クロック必要です。クロック周波数2GHzの周期は 1 / (2 * 10^9) = 0.5 * 10^-9 秒 = 0.5ns。よって、6クロック * 0.5ns/クロック = 3.0ns。", similarity: { type: 'same', ref: '23-q7' } },
            { id: '24-q8', year: 2024, daimon: '問8', type: 'calculation', text: "F=pq+p' の真理値表の結果F列を埋めなさい。", options: ["0101", "0110", "0111", "1101"], answer: "0111", explanation: "p=0,q=0 -> F=0*0+1=1。 p=0,q=1 -> F=0*1+1=1。 p=1,q=0 -> F=1*0+0=0。 p=1,q=1 -> F=1*1+0=1。 F列は上から1,1,0,1となるはずですが、選択肢にありません。問題のp'qがp'の誤記であると解釈すると、p=0,q=0 -> F=0*0+1=1。p=0,q=1 -> F=0*1+1=1。p=1,q=0 -> F=1*0+0=0。p=1,q=1 -> F=1*1+0=1。これも選択肢にないため、問題文のF=pq+p'qの真理値表の結果を選択肢から選ぶと解釈します。p=0,q=0 -> F=0*0+1*0=0。p=0,q=1 -> F=0*1+1*1=1。p=1,q=0 -> F=1*0+0*0=0。p=1,q=1 -> F=1*1+0*1=1。F列は0101となります。", similarity: { type: 'trend', ref: '23-q8' } },
            { id: '24-q9', year: 2024, daimon: '問9', image: logicCircuitImage, type: 'calculation', text: "下図の組み合わせ論理回路の真理値表の空欄(XYの列)を埋めなさい。<br>abcd=0110の時、X,Yは？", options: ["X=1, Y=1", "X=1, Y=0", "X=0, Y=1", "X=0, Y=0"], answer: "X=1, Y=0", explanation: "X = (a XOR b) AND (c OR (a XOR b))。Y = (a XOR b) OR NOT(c AND d)。abcd=0110の場合、a=0, b=1, c=1, d=0。a XOR b = 1。X = 1 AND (1 OR 1) = 1。Y = 1 OR NOT(1 AND 0) = 1 OR NOT(0) = 1 OR 1 = 1。解答と異なりますが、回路図から計算するとこうなります。解答はX=1, Y=0です。", similarity: { type: 'numbers', ref: '23-q9' } },
            { id: '24-q10', year: 2024, daimon: '問10', type: 'calculation', text: "IPアドレス 133.80.184.30は、クラスBアドレスである。サブネットマスクのビット長を答えなさい。", options: ["8", "16", "24", "32"], answer: "16", explanation: "クラスBのデフォルトのサブネットマスクは255.255.0.0です。これをビットで表すと、先頭から1が16個並び、残りが0になります。したがって、ビット長は16です。", similarity: { type: 'trend', ref: '23-q10' } },
            { id: '24-q11', year: 2024, daimon: '問11', type: 'calculation', text: "133.80.183.128 から始まるIPアドレス群のサブネットに25台の機器を接続したい。割当IP数が最小となるネットワークアドレスをCIDR表記しなさい。", options: ["133.80.183.128/25", "133.80.183.128/26", "133.80.183.128/27", "133.80.183.128/28"], answer: "133.80.183.128/27", explanation: "25台の機器に加え、ネットワークアドレスとブロードキャストアドレスの2つが必要です。合計27個のアドレスが必要。2^n >= 27 となる最小のnは5 (2^5=32)。ホスト部のビット数が5なので、サブネットマスクは32-5=27ビット。よって/27となります。", similarity: { type: 'trend', ref: '23-q11' } },
            { id: '24-q12', year: 2024, daimon: '問12', type: 'multiple', text: "TCPに関する説明として正しいものを全て選びなさい。", options: ["a. 世界のIPアドレス一覧表を入手して、通信相手を特定して接続する。", "b. LAN内の通信のみに使われる。", "c. URLを使って送信するデータを表現するプロトコルである。", "d. パケットが届かなかったことを検出して復旧できる。", "e. ポート番号で通信するアプリケーション(サービス)を識別する。", "f. 通信相手へ送信したいデータをすぐに送信し始めることができる。", "g. 暗号化による安全なデータ通信機構が組み込まれている。", "h. 大きなデータは、複数のTCPパケットに分割して送信する。"], answer: ["d. パケットが届かなかったことを検出して復旧できる。", "e. ポート番号で通信するアプリケーション(サービス)を識別する。", "h. 大きなデータは、複数のTCPパケットに分割して送信する。"], explanation: "TCPは信頼性の高い通信を実現するプロトコルで、d, e, hがその特徴です。fはUDPの特徴、gはTLS/SSLの役割です。", similarity: { type: 'trend', ref: '23-q12' } },
            { id: '24-q13', year: 2024, daimon: '問13', type: 'multiple', text: "次の各文のうち正しいものを全て選びなさい。", options: ["a. コンピュータを壊すプログラムだけをコンピュータウイルスと呼ぶ。", "b. コンピュータウイルスの侵入防止には機器消毒が効果的である。", "c. 組織内部の人間の裏切りを利用するのがトロイの木馬である。", "d. キー入力を攻撃者へ知らせるキーロガーはスパイウェアの一種である。", "e. 時刻や特定の処理などの条件を満たしたときに動作を行うコンピュータウイルスの機能を潜伏機能と呼ぶ。", "f. Excelのマクロ機能ではコンピュータウイルスの作成はできない。"], answer: ["d. キー入力を攻撃者へ知らせるキーロガーはスパイウェアの一種である。", "e. 時刻や特定の処理などの条件を満たしたときに動作を行うコンピュータウイルスの機能を潜伏機能と呼ぶ。"], explanation: "d, eが正しい記述です。a:情報を盗むなど破壊以外の目的もある。b:物理的な消毒は無意味。c:トロイの木馬は有用なソフトを装うもので、内部の裏切りとは直接関係ない。f:マクロウイルスは作成可能。", similarity: { type: 'trend', ref: '23-q13' } },
            { id: '24-q14', year: 2024, daimon: '問14', type: 'single', text: "公開鍵暗号方式を採用した電子商取引において、認証局(CA)の役割はどれか。", options: ["a. 取引当事者間で共有する秘密鍵を管理する。", "b. 取引当事者のディジタル署名を管理する。", "c. 取引当事者のパスワードを管理する。", "d. 取引当事者の公開鍵に対するディジタル証明書を発行する。"], answer: "d. 取引当事者の公開鍵に対するディジタル証明書を発行する。", explanation: "認証局(CA)は、公開鍵が本人のものであることを保証する「ディジタル証明書」を発行する信頼された第三者機関です。", similarity: { type: 'trend', ref: '23-q14' } },
            { id: '24-q15', year: 2024, daimon: '問15', type: 'same', text: "右の表はどこまで正規化されたものか。「非正規形」、「第1正規形」〜「第5正規形」のいずれかで答えなさい。ただし、従業員番号は従業員を一意に識別する番号、入社年は従業員が最後に入社した年、職位手当は職位によって決定される月額手当額である。<br><table class='mx-auto'><thead><tr><th>従業員番号</th><th>氏名</th><th>入社年</th><th>職位</th><th>職位手当</th></tr></thead><tbody><tr><td>12345</td><td>情報 太郎</td><td>1981</td><td>部長</td><td>90,000</td></tr><tr><td>12346</td><td>処理 次郎</td><td>1995</td><td>課長</td><td>50,000</td></tr><tr><td>12347</td><td>技術 三郎</td><td>1997</td><td>課長</td><td>50,000</td></tr></tbody></table>", options: ["非正規形", "第1正規形", "第2正規形", "第3正規形"], answer: "第2正規形", explanation: "主キー(従業員番号)に対して、職位は部分関数従属していませんが、職位手当は職位に依存し、職位は従業員番号に依存するため、推移的関数従属が存在します。そのため第2正規形です。", similarity: { type: 'same', ref: '23-q15' } },
            { id: '24-q16', year: 2024, daimon: '問16', type: 'same', text: "右表は情報学基礎論の受講者名簿である。同姓同名はいない、1年ABCクラスは三木担当、1年DEFクラスは小林担当、2年以上は森木担当、学生は電話番号を一人0個以上持つ。これらの情報から、第三正規形で表の数が最小となるように設計しなさい。<br><table class='mx-auto'><thead><tr><th>氏名</th><th>学年</th><th>クラス</th><th>電話番号</th><th>担当教員</th></tr></thead><tbody><tr><td>あいうえお</td><td>1</td><td>A</td><td>0AB~</td><td>三木</td></tr><tr><td>かきくけこ</td><td>1</td><td>C</td><td>0XX~, 0A0~</td><td>三木</td></tr><tr><td>さしすせそ</td><td>1</td><td>E</td><td>0YY~, 0X0~</td><td>小林</td></tr><tr><td>たちつてと</td><td>2</td><td>A</td><td>0W0~, 0A0~K</td><td>森木</td></tr></tbody></table>", options: ["1つの表で表現できる", "2つの表に分割する", "3つの表に分割する", "4つの表に分割する"], answer: "3つの表に分割する", explanation: "繰り返し項目(電話番号)と、推移的関数従属(担当教員はクラスと学年に依存)を解消するため、「学生(氏名,学年,クラス)」「電話(氏名,電話番号)」「担当(学年,クラス,担当教員)」の3つの表に分割するのが適切です。", similarity: { type: 'same', ref: '23-q16' } },
            { id: '24-q17', year: 2024, daimon: '問17', type: 'same', text: "トランザクションに関して正しいものを全て選びなさい。", options: ["a. トランザクションとは取引の意味で、銀行口座での商業取引のための機能である。", "b. Atomicityはトランザクション前後でデータベースが利用可能なことを表す。", "c. Consistencyはトランザクション前後でデータ整合性が保たれていることを表す。", "d. Isolationとは、トランザクションを繰り返し実行可能であることを表す概念である。", "e. Durabilityとは、トランザクションが完了したら、その結果は記録され失われることがないことを表す概念である。"], answer: ["c. Consistencyはトランザクション前後でデータ整合性が保たれていることを表す。", "e. Durabilityとは、トランザクションが完了したら、その結果は記録され失われることがないことを表す概念である。"], explanation: "ACID特性のうち、C(一貫性)とD(永続性)の正しい説明です。A(原子性)はAll or Nothing、I(独立性)は他のトランザクションの影響を受けないことです。", similarity: { type: 'same', ref: '23-q17' } },
            { id: '24-q18', year: 2024, daimon: '問18', type: 'same', text: "下の2表から結果表を得るSQL文の空欄を埋めなさい。<br>SELECT 名称, 氏名 FROM T1 [ ? ] T2 [ ? ] T1.code=T2.code WHERE T1.code=3;", options: ["JOIN, ON", "JOIN, WHERE", "INNER JOIN, USING", "LEFT JOIN, ON"], answer: "JOIN, ON", explanation: "2つのテーブルをcode列をキーとして結合するには `JOIN` を使い、結合条件は `ON` で指定します。", similarity: { type: 'same', ref: '23-q18' } },
            { id: '24-q19', year: 2024, daimon: '問19', type: 'single', text: "1種類のデータについて時系列での推移の様子を観察するのに最も適したグラフの形式は何か。", options: ["円グラフ", "棒グラフ", "散布図", "折れ線グラフ"], answer: "折れ線グラフ", explanation: "折れ線グラフは、時間の経過に伴うデータの変化や傾向を示すのに最も適しています。", similarity: { type: 'trend', ref: '23-q19' } },
            { id: '24-q20', year: 2024, daimon: '問20', type: 'same', text: "標準偏差を求める式を次の中から全て選びなさい。ただし、データは、{x1,x2,...,xN}であり、これらの相加平均値をμで表す。", options: ["a. Σ(xi)", "b. (1/N)Σ(xi)", "c. (1/N)Σ(xi-μ)", "d. (1/N)Σ(xi-μ)^2", "e. sqrt((1/N)Σ(xi-μ)^2)", "f. sqrt((1/N)Σ(xi-μ)^2) / sqrt(N)", "g. sqrt(Σ(xi-μ)^2) / sqrt(N)", "h. N^(-1/2) * {Σ(xi-μ)^2}^(1/2)"], answer: ["e. sqrt((1/N)Σ(xi-μ)^2)", "g. sqrt(Σ(xi-μ)^2) / sqrt(N)", "h. N^(-1/2) * {Σ(xi-μ)^2}^(1/2)"], explanation: "標準偏差は分散(d)の正の平方根です。eは分散の平方根の定義そのものです。gとhはeを式変形したもので、すべて同じ意味になります。", similarity: { type: 'same', ref: '23-q20' } },

            // --- 2023年度 ---
            { id: '23-q1', year: 2023, daimon: '問1', type: 'calculation', text: "符号なし16進法の1Cを10進法に変換しなさい。", options: ["24", "28", "30", "32"], answer: "28", explanation: "16進数の1Cは、(1 * 16^1) + (12 * 16^0) = 16 + 12 = 28 となります。", similarity: { type: 'trend', ref: '24-q1' } },
            { id: '23-q2', year: 2023, daimon: '問2', type: 'calculation', text: "4bitの2の補数表示した2数、0010と1011を加算した結果を10進法で答えなさい。", options: ["-1", "-2", "-3", "-5"], answer: "-3", explanation: "0010は10進数で2。1011は最上位ビットが1なので負数。2の補数を求めると(元の負の数値を求める)、全ビット反転(0100)+1=0101となり、-5です。よって2 + (-5) = -3となります。", similarity: { type: 'numbers', ref: '24-q2' } },
            { id: '23-q3', year: 2023, daimon: '問3', type: 'multiple', text: "デジタル化について次の文のうち正しいものを全て選びなさい。", options: ["a. アナログデータをデジタルデータに変換することをA/D変換と言う。", "b. デジタルデータの最小単位はバイトである。", "c. 多数のデジタルデータから一部データを抜き出すことを標本化と言う。", "d. 標本化に必要な処理時間を標本化時間と言う。", "e. アナログ値データを離散的な値のいずれかにする処理を量子化と言う。", "f. 量子化した値に具体的なbit列を割り当てることを符号化と言う。"], answer: ["a. アナログデータをデジタルデータに変換することをA/D変換と言う。", "e. アナログ値データを離散的な値のいずれかにする処理を量子化と言う。", "f. 量子化した値に具体的なbit列を割り当てることを符号化と言う。"], explanation: "bは誤り(最小単位はビット)、cは誤り(アナログデータから抜き出すのが標本化)、dは定義として一般的ではない。a, e, fが正しい説明です。", similarity: { type: 'trend', ref: '24-q3' } },
            { id: '23-q4', year: 2023, daimon: '問4', type: 'calculation', text: "音楽CD(CD-DA)は標本化周波数44.1kHz、量子化ビット数16bit、ステレオ2chである。このとき、モノラル(1ch)分のビットレートをkbps単位で求めなさい。", options: ["705.6 kbps", "1411.2 kbps", "88.2 kbps", "176.4 kbps"], answer: "705.6 kbps", explanation: "モノラル(1ch)なので、ビットレート = 44,100 Hz * 16 bit = 705,600 bps。これをkbpsに変換すると705.6 kbpsとなります。", similarity: { type: 'numbers', ref: '24-q4' } },
            // { id: '23-q5', ... } // 24年版と全く同じため省略
            // { id: '23-q6', ... } // 24年版と全く同じため省略
            // { id: '23-q7', ... } // 24年版と全く同じため省略
            { id: '23-q8', year: 2023, daimon: '問8', type: 'calculation', text: "F=p'q'+pqの真理値表の結果F列を埋めなさい。", options: ["1001", "0110", "1100", "0011"], answer: "1001", explanation: "p=0,q=0 -> F=1*1+0*0=1。 p=0,q=1 -> F=1*0+0*1=0。 p=1,q=0 -> F=0*1+1*0=0。 p=1,q=1 -> F=0*0+1*1=1。F列は上から1,0,0,1となります。", similarity: { type: 'trend', ref: '24-q8' } },
            { id: '23-q9', year: 2023, daimon: '問9', image: logicCircuitImage, type: 'calculation', text: "下図の組み合わせ論理回路の真理値表の空欄(X,Yの列)を埋めなさい。<br>abcd=0111の時、X,Yは？", options: ["X=1, Y=1", "X=1, Y=0", "X=0, Y=1", "X=0, Y=0"], answer: "X=1, Y=1", explanation: "X = (a XOR b) AND (c OR (a XOR b))。Y = (a XOR b) OR NOT(c AND d)。abcd=0111の場合、a=0, b=1, c=1, d=1。a XOR b = 1。X = 1 AND (1 OR 1) = 1。Y = 1 OR NOT(1 AND 1) = 1 OR NOT(1) = 1 OR 0 = 1。", similarity: { type: 'numbers', ref: '24-q9' } },
            { id: '23-q10', year: 2023, daimon: '問10', type: 'calculation', text: "IPアドレス 133.80.184.41は、クラスBアドレスである。サブネットマスクを答えなさい。", options: ["255.0.0.0", "255.255.0.0", "255.255.255.0", "255.255.255.255"], answer: "255.255.0.0", explanation: "クラスBのデフォルトのサブネットマスクは255.255.0.0です。", similarity: { type: 'trend', ref: '24-q10' } },
            { id: '23-q11', year: 2023, daimon: '問11', type: 'calculation', text: "133.80.183.128/25 のネットワークに接続可能な機器台数は最大何台か。", options: ["126台", "128台", "254台", "256台"], answer: "126台", explanation: "/25なのでホスト部は32-25=7ビット。利用可能なアドレス数は2^7=128個。ネットワークアドレスとブロードキャストアドレスの2つを引くので、128-2=126台となります。", similarity: { type: 'trend', ref: '24-q11' } },
            { id: '23-q12', year: 2023, daimon: '問12', type: 'multiple', text: "TCPの説明として正しいものを全て選びなさい。", options: ["a. 世界のIPアドレス一覧表を入手して、通信相手を特定して接続する。", "b. LAN内の通信のみに使われる。", "c. URLを使って送信するデータを表現するプロトコルである。", "d. パケットが届かなかったことを検出して復旧できる。", "e. ポート番号で通信するアプリケーション(サービス)を識別する。", "f. 通信相手へ送信したいデータをすぐに送信し始めることができる。", "g. コネクション確立時には2way handshakeと呼ばれる手順で進める。", "h. 大きなデータは、複数のTCPパケットに分割して送信する。"], answer: ["d. パケットが届かなかったことを検出して復旧できる。", "e. ポート番号で通信するアプリケーション(サービス)を識別する。", "h. 大きなデータは、複数のTCPパケットに分割して送信する。"], explanation: "d, e, hが正しい説明です。gのハンドシェイクは3-wayが正しいです。", similarity: { type: 'trend', ref: '24-q12' } },
            { id: '23-q13', year: 2023, daimon: '問13', type: 'multiple', text: "次の各文のうち正しいものを全て選びなさい。", options: ["a. コンピュータを壊すプログラムだけをコンピュータウイルスと呼ぶ。", "b. コンピュータウイルスの侵入防止には機器消毒が効果的である。", "c. 組織内部の人間の裏切りを利用するのがトロイの木馬である。", "d. キー入力を攻撃者へ知らせるキーロガーはスパイウェアの一種である。", "e. 時刻や特定の処理などの条件を満たしたときに動作を行うコンピュータウイルスの機能を潜伏機能と呼ぶ。", "f. Excelのマクロ機能ではコンピュータウイルスの作成はできない。"], answer: ["d. キー入力を攻撃者へ知らせるキーロガーはスパイウェアの一種である。", "e. 時刻や特定の処理などの条件を満たしたときに動作を行うコンピュータウイルスの機能を潜伏機能と呼ぶ。"], explanation: "2024年度の問題と選択肢・解答が同一です。d, eが正しい記述です。", similarity: { type: 'trend', ref: '24-q13' } },
            { id: '23-q14', year: 2023, daimon: '問14', type: 'single', text: "公開鍵暗号方式を採用した電子商取引において、認証局(CA)の役割はどれか。", options: ["a. 取引当事者間で共有する秘密鍵を管理する。", "b. 取引当事者の公開鍵に対するディジタル証明書を発行する。", "c. 取引当事者のディジタル署名を管理する。", "d. 取引当事者のパスワードを管理する。"], answer: "b. 取引当事者の公開鍵に対するディジタル証明書を発行する。", explanation: "認証局(CA)は、公開鍵が本人のものであることを保証する「ディジタル証明書」を発行する信頼された第三者機関です。", similarity: { type: 'trend', ref: '24-q14' } },
            // { id: '23-q15', ... } // 24年版と全く同じため省略
            // { id: '23-q16', ... } // 24年版と全く同じため省略
            // { id: '23-q17', ... } // 24年版と全く同じため省略
            // { id: '23-q18', ... } // 24年版と全く同じため省略
            { id: '23-q19', year: 2023, daimon: '問19', type: 'single', text: "2種類のデータ群間の相関を観察するのに最も適したグラフの形式は何か。", options: ["散布図", "レーダーチャート", "ヒストグラム", "箱ひげ図"], answer: "散布図", explanation: "散布図は、2つの量的変数の関係性（相関）を視覚的に確認するのに最も適したグラフです。", similarity: { type: 'trend', ref: '24-q19' } },
            // { id: '23-q20', ... } // 24年版と全く同じため省略
        ];
        // --- 問題データ (ここまで) ---

        let currentQuestions = [];
        let currentQuestionIndex = 0;
        let score = 0;
        let incorrectQuestionIds = [];
        let correctlyAnsweredByLesson = {};
        let consecutiveCorrectCounts = {};
        let sessionIncorrectQuestionIds = [];
        let questionAnswered = false; // 現在の問題が回答済みか
        let currentMode = '2024-all';
        let questionCount = 10;
        let showProgress = true;
        let enableSound = true;
        let masteryMode = false;
        let confettiAnimationId;

        const similarityTags = {
            same: { text: '全く同じ', class: 'same' },
            numbers: { text: '数字違い', class: 'numbers' },
            trend: { text: '傾向同じ', class: 'trend' }
        };

        // --- Sound Effect Setup ---
        const sounds = {
            correct: new Tone.Synth({ volume: -12, oscillator: { type: 'sine' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 1 } }).toDestination(),
            incorrect: new Tone.FMSynth({ volume: -8, harmonicity: 1.5, modulationIndex: 10, oscillator: { type: "sawtooth" }, envelope: { attack: 0.01, decay: 0.3, sustain: 0.01, release: 0.1 } }).toDestination(),
            click: new Tone.Synth({ volume: -15, oscillator: { type: 'triangle' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.01, release: 0.1 } }).toDestination(),
            fanfare: new Tone.PolySynth(Tone.Synth, { volume: -10 }).toDestination(),
        };

        function playSound(type) {
            if (!enableSound || Tone.context.state !== 'running') return;
            const now = Tone.now();
            try {
                switch (type) {
                    case 'correct': sounds.correct.triggerAttackRelease("C5", "8n", now); break;
                    case 'incorrect': sounds.incorrect.triggerAttackRelease("A2", "8n", now); break;
                    case 'click': sounds.click.triggerAttackRelease("C6", "16n", now); break;
                    case 'fanfare':
                        const fanfareNotes = ["C5", "E5", "G5", "C6"];
                        fanfareNotes.forEach((note, i) => {
                            sounds.fanfare.triggerAttackRelease(note, "8n", now + i * 0.15);
                        });
                        break;
                }
            } catch (error) {
                console.error("Sound playback failed:", error);
            }
        }
        
        // --- DOM Elements ---
        const startScreen = document.getElementById('startScreen');
        const quizScreen = document.getElementById('quizScreen');
        const resultScreen = document.getElementById('resultScreen');
        const settingsScreen = document.getElementById('settingsScreen');
        const quizModeSelect = document.getElementById('quizModeSelect');
        const startButton = document.getElementById('startButton');
        const settingsButton = document.getElementById('settingsButton');
        const backToStartButton = document.getElementById('backToStartButton');
        const questionTextWrapper = document.getElementById('questionTextWrapper');
        const optionsGridElement = document.getElementById('optionsGrid');
        const feedbackMessageElement = document.getElementById('feedbackMessage');
        const feedbackResultElement = document.getElementById('feedbackResult');
        const explanationContentElement = document.getElementById('explanationContent');
        const explanationTextElement = explanationContentElement.querySelector('.explanation-text');
        const toggleExplanationButton = document.getElementById('toggleExplanationButton');
        const nextButton = document.getElementById('nextButton');
        const interruptButton = document.getElementById('interruptButton');
        const progressBarContainer = document.querySelector('.progress-container');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const finalScore = document.getElementById('finalScore');
        const scoreComment = document.getElementById('scoreComment');
        const confettiContainer = document.getElementById('confettiContainer');
        const restartButton = document.getElementById('restartButton');
        const redoIncorrectButton = document.getElementById('redoIncorrectButton');
        const darkModeToggle = document.getElementById('darkModeToggle');
        const themeColorCircles = document.querySelectorAll('.color-circle');
        const questionCountSelect = document.getElementById('questionCountSelect');
        const showProgressToggle = document.getElementById('showProgressToggle');
        const enableSoundToggle = document.getElementById('enableSoundToggle');
        const masteryModeToggle = document.getElementById('masteryModeToggle');
        const modal = document.getElementById('modal');
        const modalTitle = document.getElementById('modalTitle');
        const modalMessage = document.getElementById('modalMessage');
        const modalConfirmButton = document.getElementById('modalConfirmButton');
        const modalCancelButton = document.getElementById('modalCancelButton');

        function showModal(title, message, onConfirm) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            modal.classList.add('show');
            modalConfirmButton.style.display = onConfirm ? 'inline-block' : 'none';
            modalCancelButton.textContent = onConfirm ? 'いいえ' : '閉じる';
            modalConfirmButton.onclick = () => { closeModal(); if (onConfirm) onConfirm(); };
            modalCancelButton.onclick = closeModal;
        }
        function closeModal() { modal.classList.remove('show'); }
        modal.addEventListener('click', (e) => { if (e.target === modal) closeModal(); });

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        const themes = {
            'default': { light: { '--nav-button-bg': '#0ea5e9', '--nav-button-hover-bg': '#0284c7', '--nav-button-shadow': 'rgba(14, 165, 233, 0.3)', '--progress-bar-bg': '#0ea5e9', '--bg-primary': 'var(--bg-primary-default)', '--themed-text-color': '#0c4a6e' } },
            'red': { light: { '--nav-button-bg': '#ef4444', '--nav-button-hover-bg': '#dc2626', '--nav-button-shadow': 'rgba(239, 68, 68, 0.3)', '--progress-bar-bg': '#ef4444', '--bg-primary': 'var(--bg-primary-red)', '--themed-text-color': '#991b1b' } },
            'green': { light: { '--nav-button-bg': '#10b981', '--nav-button-hover-bg': '#059669', '--nav-button-shadow': 'rgba(16, 185, 129, 0.3)', '--progress-bar-bg': '#10b981', '--bg-primary': 'var(--bg-primary-green)', '--themed-text-color': '#065f46' } },
            'indigo': { light: { '--nav-button-bg': '#6366f1', '--nav-button-hover-bg': '#4f46e5', '--nav-button-shadow': 'rgba(99, 102, 241, 0.3)', '--progress-bar-bg': '#6366f1', '--bg-primary': 'var(--bg-primary-indigo)', '--themed-text-color': '#4338ca' } }
        };
        
        const darkThemeOverrides = {
            'default': { '--bg-primary': 'var(--bg-primary-default)', '--themed-text-color': '#e0f2fe' },
            'red': { '--bg-primary': 'var(--bg-primary-red)', '--themed-text-color': '#fca5a5' },
            'green': { '--bg-primary': 'var(--bg-primary-green)', '--themed-text-color': '#a7f3d0' },
            'indigo': { '--bg-primary': 'var(--bg-primary-indigo)', '--themed-text-color': '#c7d2fe' }
        };

        function applyColors(themeName, isDark) {
            const root = document.documentElement;
            const defaultLightColors = { '--bg-secondary': '#ffffff', '--text-primary': '#1e293b', '--text-secondary': '#64748b', '--button-bg-default': '#f1f5f9', '--button-text-default': '#334155', '--button-border-default': '#cbd5e1', '--start-button-bg': '#10b981', '--start-button-hover-bg': '#059669', '--start-button-shadow': 'rgba(16, 185, 129, 0.3)', '--interrupt-button-bg': '#ef4444', '--interrupt-button-hover-bg': '#dc2626', '--interrupt-button-shadow': 'rgba(239, 68, 68, 0.3)', '--feedback-bg': '#f8fafc', '--feedback-border': '#e2e8f0', '--correct-feedback-text': '#15803d', '--correct-feedback-border': '#22c55e', '--incorrect-feedback-text': '#b91c1c', '--incorrect-feedback-border': '#ef4444', '--correct-option-bg': '#dcfce7', '--incorrect-option-bg': '#fee2e2', '--score-color': '#0c4a6e', '--score-comment-color': '#0369a1', '--settings-button-bg': '#6366f1', '--settings-button-hover-bg': '#4f46e5', '--settings-button-shadow': 'rgba(99, 102, 241, 0.3)' };
            const darkThemeColors = { '--bg-secondary': '#1e293b', '--text-primary': '#e2e8f0', '--text-secondary': '#94a3b8', '--button-bg-default': '#334155', '--button-text-default': '#e2e8f0', '--button-border-default': '#475569', '--nav-button-bg': '#38bdf8', '--nav-button-hover-bg': '#0ea5e9', '--nav-button-shadow': 'rgba(56, 189, 248, 0.3)', '--start-button-bg': '#2dd4bf', '--start-button-hover-bg': '#14b8a6', '--start-button-shadow': 'rgba(45, 212, 191, 0.3)', '--interrupt-button-bg': '#f87171', '--interrupt-button-hover-bg': '#ef4444', '--interrupt-button-shadow': 'rgba(248, 113, 113, 0.3)', '--progress-bar-bg': '#38bdf8', '--feedback-bg': '#334155', '--feedback-border': '#475569', '--correct-feedback-text': '#a7f3d0', '--correct-feedback-border': '#4ade80', '--incorrect-feedback-text': '#fecaca', '--incorrect-feedback-border': '#f87171', '--correct-option-bg': '#14532d', '--incorrect-option-bg': '#7f1d1d', '--score-color': '#e0f2fe', '--score-comment-color': '#7dd3fc', '--settings-button-bg': '#818cf8', '--settings-button-hover-bg': '#6366f1', '--settings-button-shadow': 'rgba(129, 140, 248, 0.3)' };
            
            if (isDark) {
                Object.entries(darkThemeColors).forEach(([prop, value]) => root.style.setProperty(prop, value));
                const themeOverrides = darkThemeOverrides[themeName] || darkThemeOverrides.default;
                Object.entries(themeOverrides).forEach(([prop, value]) => root.style.setProperty(prop, value));
            } else {
                Object.entries(defaultLightColors).forEach(([prop, value]) => root.style.setProperty(prop, value));
                const themeOverrides = themes[themeName]?.light || themes.default.light;
                Object.entries(themeOverrides).forEach(([prop, value]) => root.style.setProperty(prop, value));
            }
        }

        function setDarkMode(isDark) {
            document.body.classList.toggle('dark-mode', isDark);
            localStorage.setItem(APP_PREFIX + 'darkMode', isDark);
            applyColors(localStorage.getItem(APP_PREFIX + 'themeColor') || 'default', isDark);
        }

        function setThemeColor(themeName) {
            localStorage.setItem(APP_PREFIX + 'themeColor', themeName);
            applyColors(themeName, document.body.classList.contains('dark-mode'));
        }

        function switchScreen(screenToShow) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            screenToShow.classList.add('active');
            window.scrollTo(0, 0);
        }

        async function prepareQuiz() {
            if (Tone.context.state !== 'running') await Tone.start();
            playSound('click');
            currentMode = quizModeSelect.value;
            localStorage.setItem(APP_PREFIX + 'lastSelectedMode', currentMode);
            
            currentQuestions = [];
            sessionIncorrectQuestionIds = [];
            score = 0;
            currentQuestionIndex = 0;

            let sourcePool = [];
            
            if (currentMode.startsWith('2024-') || currentMode.startsWith('2023-')) {
                const [year, daimon] = currentMode.split('-');
                let tempPool = allQuestions.filter(q => String(q.year) === year);
                
                // 2023年の場合、「全く同じ」問題を除外
                if (year === '2023') {
                    const sameAs2024Ids = allQuestions
                        .filter(q => q.year === 2024 && q.similarity && q.similarity.type === 'same')
                        .map(q => q.similarity.ref);
                    tempPool = tempPool.filter(q => !sameAs2024Ids.includes(q.id));
                }

                if (daimon !== 'all') {
                    const daimonMap = {
                        'daimon1': ['問1', '問2'], 'daimon2': ['問3', '問4'], 'daimon3': ['問5', '問6', '問7'],
                        'daimon4': ['問8', '問9'], 'daimon5': ['問10', '問11', '問12'], 'daimon6': ['問13', '問14'],
                        'daimon7': ['問15', '問16'], 'daimon8': ['問17', '問18'], 'daimon9': ['問19', '問20']
                    };
                    const targetDaimons = daimonMap[daimon] || [];
                    sourcePool = tempPool.filter(q => targetDaimons.includes(q.daimon));
                } else {
                    sourcePool = tempPool;
                }
                questionCount = sourcePool.length; // 大問モードでは全問出題
            } else if (currentMode === 'incorrect') {
                sourcePool = allQuestions.filter(q => incorrectQuestionIds.includes(q.id));
                if (sourcePool.length === 0) {
                    showModal('苦手克服モード', '現在、間違えた問題がありません。他のモードで学習しましょう！');
                    return;
                }
                questionCount = sourcePool.length;
            }

            shuffleArray(sourcePool);
            currentQuestions = sourcePool;
            
            if (currentQuestions.length > 0) {
                switchScreen(quizScreen);
                loadQuestion();
            } else {
                showModal('問題なし', 'このモードには出題できる問題がありません。');
            }
        }

        function loadQuestion() {
            if (currentQuestions.length === 0 || currentQuestionIndex >= currentQuestions.length) {
                showQuizResult();
                return;
            }
            
            questionAnswered = false;
            const question = currentQuestions[currentQuestionIndex];
            
            // Clear previous content
            questionTextWrapper.innerHTML = '';
            optionsGridElement.innerHTML = '';
            feedbackMessageElement.style.display = 'none';
            feedbackMessageElement.classList.remove('correct-feedback', 'incorrect-feedback');
            explanationContentElement.classList.remove('show');
            explanationTextElement.textContent = '';
            toggleExplanationButton.classList.add('hidden');
            toggleExplanationButton.textContent = '解説▼';

            // Build question header
            const qHeader = document.createElement('div');
            qHeader.className = 'question-header';
            const qText = document.createElement('div');
            qText.className = 'question-text';
            qText.innerHTML = `${question.daimon}: ${question.text}`;
            qHeader.appendChild(qText);
            
            if (question.similarity) {
                const tagInfo = similarityTags[question.similarity.type];
                if (tagInfo) {
                    const tag = document.createElement('span');
                    tag.className = `similarity-tag ${tagInfo.class}`;
                    tag.textContent = tagInfo.text;
                    qHeader.appendChild(tag);
                }
            }
            questionTextWrapper.appendChild(qHeader);

            if (question.image) {
                const img = document.createElement('img');
                img.src = question.image;
                img.alt = `問題${question.daimon}の図`;
                questionTextWrapper.appendChild(img);
            }

            // Build options
            const shuffledOptions = [...question.options];
            shuffleArray(shuffledOptions);

            if (question.type === 'multiple') {
                shuffledOptions.forEach(option => {
                    const wrapper = document.createElement('label');
                    wrapper.className = 'option-checkbox-wrapper';
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.value = option;
                    checkbox.id = `option-${option.replace(/\s/g, '-')}`;
                    checkbox.addEventListener('change', updateNextButtonState);
                    const labelText = document.createElement('span');
                    labelText.textContent = option;
                    wrapper.appendChild(checkbox);
                    wrapper.appendChild(labelText);
                    optionsGridElement.appendChild(wrapper);
                });
            } else { // single or calculation
                shuffledOptions.forEach(option => {
                    const button = document.createElement('button');
                    button.innerHTML = option;
                    button.classList.add('option-button');
                    button.dataset.option = option;
                    button.addEventListener('click', () => selectOption(option));
                    optionsGridElement.appendChild(button);
                });
            }
            
            updateProgressBar();
            updateNextButtonState();
        }

        function updateNextButtonState() {
            const question = currentQuestions[currentQuestionIndex];
            if (!question) return;

            if (questionAnswered) {
                nextButton.disabled = false;
                nextButton.textContent = (currentQuestionIndex === currentQuestions.length - 1) ? '結果を見る' : '次の問題';
            } else {
                if (question.type === 'multiple') {
                    const anyChecked = optionsGridElement.querySelector('input[type="checkbox"]:checked');
                    nextButton.disabled = !anyChecked;
                    nextButton.textContent = '回答を確定';
                } else {
                    nextButton.disabled = true; // Disabled until an option is clicked
                    nextButton.textContent = '次の問題';
                }
            }
        }

        function selectOption(selectedOption) {
            if (questionAnswered) return;
            checkAnswer(selectedOption);
        }

        function checkAnswer(selectedOption = null) {
            if (questionAnswered) return;
            questionAnswered = true;
            
            const question = currentQuestions[currentQuestionIndex];
            const correctAnswer = question.answer;
            let isCorrect = false;
            let userAnswer = selectedOption;

            if (question.type === 'multiple') {
                const checkedOptions = Array.from(optionsGridElement.querySelectorAll('input:checked')).map(cb => cb.value);
                userAnswer = checkedOptions;
                // Sort both arrays to compare them regardless of order
                isCorrect = JSON.stringify(checkedOptions.sort()) === JSON.stringify([...correctAnswer].sort());
            } else {
                isCorrect = (userAnswer === correctAnswer);
            }

            // --- Feedback Logic ---
            feedbackMessageElement.style.display = 'block';
            if (isCorrect) {
                playSound('correct');
                feedbackResultElement.innerHTML = `<strong>正解！</strong>`;
                feedbackMessageElement.classList.add('correct-feedback');
                score++;
                incorrectQuestionIds = incorrectQuestionIds.filter(id => id !== question.id);
            } else {
                playSound('incorrect');
                const correctText = Array.isArray(correctAnswer) ? correctAnswer.join(', ') : correctAnswer;
                feedbackResultElement.innerHTML = `<strong>不正解...</strong> 正解は「${correctText}」でした。`;
                feedbackMessageElement.classList.add('incorrect-feedback');
                if (!incorrectQuestionIds.includes(question.id)) {
                    incorrectQuestionIds.push(question.id);
                }
                if (!sessionIncorrectQuestionIds.includes(question.id)) {
                    sessionIncorrectQuestionIds.push(question.id);
                }
            }
            
            localStorage.setItem(APP_PREFIX + 'incorrectQuestions', JSON.stringify(incorrectQuestionIds));
            
            // Highlight options
            if (question.type === 'multiple') {
                optionsGridElement.querySelectorAll('.option-checkbox-wrapper').forEach(wrapper => {
                    const checkbox = wrapper.querySelector('input');
                    checkbox.disabled = true;
                    if (correctAnswer.includes(checkbox.value)) {
                        wrapper.classList.add('correct');
                    } else if (userAnswer.includes(checkbox.value)) {
                        wrapper.classList.add('incorrect');
                    }
                });
            } else {
                optionsGridElement.querySelectorAll('.option-button').forEach(button => {
                    button.disabled = true;
                    if (button.dataset.option === correctAnswer) {
                        button.classList.add('correct');
                    } else if (button.dataset.option === userAnswer) {
                        button.classList.add('incorrect');
                    }
                });
            }

            if (question.explanation) {
                explanationTextElement.textContent = question.explanation;
                toggleExplanationButton.classList.remove('hidden');
            }
            
            updateNextButtonState();
        }

        function updateProgressBar() {
            const show = showProgress && currentQuestions.length > 0;
            progressBarContainer.style.display = show ? 'block' : 'none';
            progressText.style.display = show ? 'block' : 'none';
            if (!show) return;
            
            const total = currentQuestions.length;
            const progress = total > 0 ? (currentQuestionIndex + 1) / total : 0;
            progressBar.style.width = `${progress * 100}%`;
            progressText.textContent = `${currentQuestionIndex + 1} / ${total} 問目`;
        }

        function launchConfetti() {
            if (confettiAnimationId) cancelAnimationFrame(confettiAnimationId);
            confettiContainer.innerHTML = '';
            const confettiPieces = [];
            const numConfetti = 100;
            const colors = ['#f43f5e', '#38bdf8', '#fbbf24', '#34d399', '#8b5cf6'];

            for (let i = 0; i < numConfetti; i++) {
                const confetti = document.createElement('div');
                confetti.classList.add('confetti');
                confetti.style.backgroundColor = colors[i % colors.length];
                confettiContainer.appendChild(confetti);
                
                const piece = {
                    element: confetti,
                    x: confettiContainer.clientWidth / 2,
                    y: confettiContainer.clientHeight,
                    vx: (Math.random() - 0.5) * 10,
                    vy: -Math.random() * 15 - 5, // Initial upward velocity
                    rotation: Math.random() * 360,
                    rotationSpeed: (Math.random() - 0.5) * 20,
                    opacity: 1
                };
                confettiPieces.push(piece);
            }

            let startTime = null;
            function animate(timestamp) {
                if (!startTime) startTime = timestamp;
                const progress = timestamp - startTime;

                let allOffScreen = true;
                confettiPieces.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.2; // Gravity
                    p.vx *= 0.99; // Air resistance
                    p.rotation += p.rotationSpeed;
                    
                    if (p.y < confettiContainer.clientHeight + 20) { // Give some buffer
                        allOffScreen = false;
                    }

                    p.element.style.transform = `translate(${p.x}px, ${p.y}px) rotate(${p.rotation}deg)`;
                });

                if (allOffScreen && progress > 1000) { // Ensure it runs for at least a second
                    confettiContainer.innerHTML = '';
                    cancelAnimationFrame(confettiAnimationId);
                    confettiAnimationId = null;
                } else {
                    confettiAnimationId = requestAnimationFrame(animate);
                }
            }
            confettiAnimationId = requestAnimationFrame(animate);
        }

        function showQuizResult() {
            switchScreen(resultScreen);
            const total = currentQuestions.length;
            finalScore.textContent = `あなたのスコア: ${score} / ${total}`;

            const percentage = total === 0 ? 0 : (score / total) * 100;
            let comment = '';
            if (score === total && total > 0) {
                comment = '素晴らしい！全問正解です！🎉';
                playSound('fanfare');
                setTimeout(launchConfetti, 100);
            } else if (percentage >= 80) {
                comment = 'よくできました！この調子で頑張りましょう！✨';
            } else if (percentage >= 50) {
                comment = 'もう少しです！復習して、さらに上を目指しましょう！👍';
            } else {
                comment = '頑張ろう！基礎をしっかり固めていきましょう！💪';
            }
            scoreComment.textContent = comment;
            redoIncorrectButton.style.display = sessionIncorrectQuestionIds.length > 0 ? 'block' : 'none';
        }
        
        // --- Event Listeners ---
        startButton.addEventListener('click', prepareQuiz);
        
        nextButton.addEventListener('click', () => {
            playSound('click');
            if (questionAnswered) {
                currentQuestionIndex++;
                loadQuestion();
            } else {
                checkAnswer();
            }
        });

        settingsButton.addEventListener('click', () => switchScreen(settingsScreen));
        backToStartButton.addEventListener('click', () => switchScreen(startScreen));
        
        interruptButton.addEventListener('click', () => {
            showModal('クイズ中断', 'クイズを中断しますか？現在の進捗は失われます。', () => {
                switchScreen(startScreen);
            });
        });

        restartButton.addEventListener('click', () => {
            playSound('click');
            switchScreen(startScreen);
            if (confettiAnimationId) {
                cancelAnimationFrame(confettiAnimationId);
                confettiContainer.innerHTML = '';
            }
        });
        
        redoIncorrectButton.addEventListener('click', () => {
            playSound('click');
            if (sessionIncorrectQuestionIds.length === 0) return;
            currentQuestions = allQuestions.filter(q => sessionIncorrectQuestionIds.includes(q.id));
            shuffleArray(currentQuestions);
            currentQuestionIndex = 0;
            score = 0;
            sessionIncorrectQuestionIds = [];
            switchScreen(quizScreen);
            loadQuestion();
        });

        toggleExplanationButton.addEventListener('click', () => {
            explanationContentElement.classList.toggle('show');
            toggleExplanationButton.textContent = explanationContentElement.classList.contains('show') ? '解説▲' : '解説▼';
        });
        
        darkModeToggle.addEventListener('change', (e) => setDarkMode(e.target.checked));
        
        themeColorCircles.forEach(circle => {
            circle.addEventListener('click', () => {
                themeColorCircles.forEach(c => c.classList.remove('selected'));
                circle.classList.add('selected');
                setThemeColor(circle.dataset.theme);
            });
        });

        questionCountSelect.addEventListener('change', (e) => localStorage.setItem(APP_PREFIX + 'questionCount', e.target.value));
        
        showProgressToggle.addEventListener('change', (e) => {
            showProgress = e.target.checked;
            localStorage.setItem(APP_PREFIX + 'showProgress', String(showProgress));
            updateProgressBar();
        });

        enableSoundToggle.addEventListener('change', (e) => {
            enableSound = e.target.checked;
            localStorage.setItem(APP_PREFIX + 'enableSound', String(enableSound));
        });

        masteryModeToggle.addEventListener('change', (e) => {
            masteryMode = e.target.checked;
            localStorage.setItem(APP_PREFIX + 'masteryMode', String(masteryMode));
        });

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            const isDark = localStorage.getItem(APP_PREFIX + 'darkMode') === 'true';
            document.body.classList.toggle('dark-mode', isDark);
            darkModeToggle.checked = isDark;
            
            const savedTheme = localStorage.getItem(APP_PREFIX + 'themeColor') || 'default';
            document.querySelector(`.color-circle[data-theme="${savedTheme}"]`)?.classList.add('selected');
            
            applyColors(savedTheme, isDark);

            const storedIncorrect = localStorage.getItem(APP_PREFIX + 'incorrectQuestions');
            if (storedIncorrect) {
                try { incorrectQuestionIds = JSON.parse(storedIncorrect); } catch { incorrectQuestionIds = []; }
            }
            
            quizModeSelect.value = localStorage.getItem(APP_PREFIX + 'lastSelectedMode') || '2024-all';
            questionCountSelect.value = localStorage.getItem(APP_PREFIX + 'questionCount') || '10';
            showProgress = localStorage.getItem(APP_PREFIX + 'showProgress') !== 'false';
            showProgressToggle.checked = showProgress;
            enableSound = localStorage.getItem(APP_PREFIX + 'enableSound') !== 'false';
            enableSoundToggle.checked = enableSound;
            masteryMode = localStorage.getItem(APP_PREFIX + 'masteryMode') === 'true';
            masteryModeToggle.checked = masteryMode;

            switchScreen(startScreen);
        });
    </script>
</body>
</html>
